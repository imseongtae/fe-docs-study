# General HTML performance considerations
빠르게 로드되는 웹사이트를 만들기 위한 첫 번째 단계는 페이지의 HTML에 대해 서버로부터 신속한 응답을 받는 것이다. 브라우저의 주소창에 URL을 입력하면, 브라우저는 해당 URL을 가져오기 위해 서버에 GET 요청을 보낸다. 웹 페이지에 대한 첫 번째 요청은 HTML 리소스를 위한 것이며, 지연을 최소화한 상태로 HTML이 빠르게 도착하도록 하는 것이 핵심 성능 목표다.

HTML에 대한 초기 요청은 여러 단계를 거치며, 각 단계는 시간이 소요된다. 각 단계에서 소요되는 시간을 줄이면 Time to First Byte (TTFB, 최초 바이트 도달 시간)를 더 빠르게 만들 수 있다. TTFB는 페이지 로드 속도를 평가할 때 유일하게 집중해야 할 지표는 아니지만, TTFB가 높을 경우 Largest Contentful Paint (LCP, 최대 콘텐츠 페인트)나 First Contentful Paint (FCP, 첫 콘텐츠 페인트)와 같은 지표에서 “양호” 기준을 달성하기 어렵게 만든다.

## Table of contents
1. [Minimize redirects](#minimize-redirects)
1. [Cache HTML responses](#cache-html-responses)
1. [Measure server response times](#measure-server-response-times)
1. [Compression](#compression)
1. [Content Delivery Networks (CDNs)](#content-delivery-networks-cdns)
1. [Test your knowledge](#test-your-knowledge)
1. [Up next: Understanding the critical path](#up-next-understanding-the-critical-path)

---

## Minimize redirects
리디렉션 최소화

리소스가 요청되면, 서버는 영구 리디렉션(301 Moved Permanently 응답)이나 임시 리디렉션(302 Found 응답)으로 응답할 수 있다.

리디렉션은 페이지 로드 속도를 늦춘다. 브라우저가 새로운 위치로 추가 HTTP 요청을 보내 리소스를 다시 가져와야 하기 때문이다. 리디렉션에는 두 가지 유형이 있다:
1.	동일 출처(Same-origin) 리디렉션: 전적으로 동일한 출처(origin) 내에서 발생하며, 리디렉션을 관리하는 로직이 웹 서버 내에 있기 때문에 완전히 제어할 수 있다.
2.	교차 출처(Cross-origin) 리디렉션: 다른 출처에 의해 시작되며, 일반적으로 제어할 수 없다.

광고, URL 단축 서비스, 기타 서드파티 서비스는 교차 출처 리디렉션을 사용하는 경우가 많다. 이런 리디렉션은 제어가 불가능한 경우가 많지만, 예를 들어 HTTP 페이지로 연결된 광고가 다시 HTTPS로 리디렉션되는 상황처럼, 여러 단계의 리디렉션을 피해야 한다. 교차 출처 리디렉션이 귀하의 출처로 도달한 뒤 동일 출처 리디렉션을 유발하는 경우도 마찬가지다.

---

## Cache HTML responses
**HTML 응답 캐시하기**

HTML 응답을 캐시하는 것은 어렵다. 그 이유는 CSS, JavaScript, 이미지, 기타 리소스 등 다른 중요 리소스에 대한 링크가 HTML 응답에 포함될 수 있기 때문이다. 이들 리소스는 종종 파일 내용에 따라 변경되는 고유한 지문(fingerprint)을 파일명에 포함하는데, 이는 배포 후 HTML 문서가 오래된 참조를 포함하게 되어 캐시된 문서가 구식이 될 수 있다는 뜻이다.

그럼에도 불구하고, 짧은 캐시 수명(예: 전혀 캐시하지 않는 것보다는)을 설정하면 이점이 있다. 예를 들어, CDN에서 리소스를 캐시해 오리진 서버의 요청 수를 줄일 수 있고, 브라우저에서는 다시 다운로드하지 않고 리소스를 재검증하는 방식으로 사용할 수 있다. 이 접근 방식은 어떤 상황에서도 변경되지 않는 정적 콘텐츠에 가장 적합하며, 캐시 수명을 몇 분 정도로 설정하면 된다. 예를 들어 정적 HTML 리소스에 대해 5분은 적절한 선택이며, 주기적인 업데이트도 무시되지 않게 한다.

만약 HTML 콘텐츠가 개인화된 경우(예: 로그인 사용자에게 맞춤 응답 제공), 보안성과 최신성(security and freshness) 등의 이유로 캐시를 전혀 하지 않는 것이 바람직하다. 사용자의 브라우저에 HTML 응답이 캐시되면 캐시를 무효화할 수 없기 때문에, 이런 경우에는 HTML 캐시를 피하는 것이 좋다.

조심스러운 HTML 캐시 접근 방식은 ETag 또는 Last-Modified 응답 헤더를 사용하는 것이다. ETag(엔터티 태그)는 리소스를 고유하게 식별하는 식별자이며, 일반적으로 리소스의 내용을 해시하여 생성한다:

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

리소스가 변경될 때마다 새로운 ETag 값을 생성해야 한다. 이후 브라우저는 If-None-Match 요청 헤더를 통해 기존 ETag 값을 서버에 전달한다. 서버가 이 값과 일치하는 경우, 304 Not Modified 응답을 반환하고 브라우저는 기존 캐시된 리소스를 사용한다. 이 경우 네트워크 지연은 발생하지만 전체 HTML 리소스보다 훨씬 작다.

하지만 리소스의 최신성을 재검증하는 데 따른 네트워크 지연 자체도 단점이 될 수 있다. 웹 개발의 많은 측면과 마찬가지로, 이 또한 트레이드오프가 존재한다. HTML 캐시를 위한 추가적인 노력이 가치 있는지를 판단하는 것은 전적으로 여러분에게 달려 있다.

---

## Measure server response times
서버 응답 시간 측정하기

응답이 캐시되지 않은 경우, 서버의 응답 시간은 호스팅 제공자와 백엔드 애플리케이션 스택에 크게 의존한다.
예를 들어, 데이터베이스에서 데이터를 가져오는 등의 동적 응답을 제공하는 웹 페이지는, 백엔드에서 큰 연산 없이 즉시 제공할 수 있는 정적 웹 페이지보다 더 높은 TTFB(Time to First Byte, 최초 바이트 도달 시간)를 가질 수 있다. 로딩 스피너를 먼저 표시하고 데이터를 클라이언트 측에서 모두 가져오는 방식은 더 예측 가능한 서버 측 환경에서 불확실성이 더 큰 클라이언트 측 환경으로 작업을 옮기는 것이다. 클라이언트 측 작업을 최소화하면 보통 사용자 중심의 측정 지표가 개선된다.

사용자들이 실제 환경에서 느린 TTFB를 겪고 있다면, Server-Timing 응답 헤더를 사용하여 서버에서 시간이 소요된 부분에 대한 정보를 노출할 수 있다:

```
Server-Timing: auth;dur=55.5, db;dur=220
```

Server-Timing 헤더의 값은 여러 지표를 포함할 수 있으며, 각 지표에 대해 지속 시간(duration)을 명시할 수 있다. 이 데이터는 Navigation Timing API를 통해 사용자 측에서 수집하고 분석할 수 있으며, 실제 사용자들이 지연을 겪고 있는지를 확인할 수 있다.

위의 코드 예시에서 응답 헤더에는 두 가지 타이밍이 포함되어 있다:
- 사용자 인증(auth)에 걸린 시간: 55.5밀리초
- 데이터베이스 접근(db)에 걸린 시간: 220밀리초

또한, 여러분의 호스팅 인프라를 검토하고, 현재 웹사이트가 받고 있는 트래픽을 처리할 수 있는 충분한 리소스를 확보하고 있는지 확인해야 한다. 공유 호스팅 서비스는 일반적으로 높은 TTFB를 초래하기 쉬우며, 더 빠른 응답 시간을 제공하는 전용 호스팅 솔루션은 비용이 더 높을 수 있다.

---

## Compression
**압축**

HTML, JavaScript, CSS, SVG 이미지 등 텍스트 기반 응답은 전송 크기를 줄여 네트워크에서 더 빠르게 다운로드되도록 압축되어야 한다.
가장 널리 사용되는 압축 알고리즘은 gzip과 Brotli이다.
Brotli는 gzip보다 약 15%에서 20% 정도 더 우수한 성능을 보인다.

대부분의 웹 호스팅 제공자는 압축을 자동으로 설정해두지만, 직접 압축 설정을 구성하거나 조정할 수 있는 위치에 있다면 다음의 중요한 사항을 고려해야 한다:

### 1. 가능하다면 Brotli를 사용
앞서 언급했듯이 Brotli는 gzip보다 확실한 성능 향상을 제공하며, 모든 주요 브라우저에서 지원된다.
가능하다면 Brotli를 사용하되, 구형 브라우저를 사용하는 사용자가 많다면 gzip을 백업용으로 설정하라.
어떤 압축도 없는 것보다는 gzip이라도 사용하는 것이 훨씬 낫다.

### 2. 파일 크기는 중요
1KiB 미만의 매우 작은 리소스는 압축 효과가 거의 없거나, 아예 압축되지 않을 수 있다.
데이터 압축의 효과는 압축 알고리즘이 패턴을 찾아내기 충분한 데이터가 있을 때 비로소 발휘된다.
파일이 클수록 압축 효과는 커지지만, 단지 압축 효과를 위해 큰 파일을 보내는 것은 좋지 않다.
예를 들어, JavaScript나 CSS 같은 대형 리소스는 압축을 풀고 난 뒤 파싱과 평가에 더 많은 시간이 소요되며, 아주 작은 변경만 있어도 전체 파일 해시가 달라지므로 더 자주 교체되어야 할 수 있다.

### 3. 동적 압축과 정적 압축 차이 이해
동적 압축은 리소스를 요청할 때마다 실시간으로 압축하는 방식이다.
반면, 정적 압축은 사전에 파일을 압축해두어 요청 시 별도로 압축을 수행하지 않아도 되는 방식이다.
정적 압축은 압축 과정 자체의 지연을 제거하므로, 동적 압축보다 서버 응답 시간에 더 유리하다.
JavaScript, CSS, SVG 이미지 등과 같은 정적 리소스는 정적으로 압축되어야 하며,
인증된 사용자에게 동적으로 생성되는 HTML과 같은 경우는 동적 압축이 적합하다.

압축을 직접 설정하는 일은 까다롭기 때문에, 대부분의 경우 다음 절에서 다룰 CDN(Content Delivery Network)에게 이를 맡기는 것이 좋다. 하지만 이런 개념들을 알고 있다면 여러분의 호스팅 제공자가 압축을 올바르게 사용하고 있는지 판단하는 데 도움이 되며, 웹사이트의 압축 설정을 개선하여, 웹 사이트에 최대한 이점을 얻는 기회를 찾는 데 유용하다.

---

## Content Delivery Networks (CDNs)
콘텐츠 전송 네트워크 (CDN)

CDN(Content Delivery Network)은 오리진 서버(origin server)의 리소스를 캐싱하는 분산된 서버 네트워크이며, 이를 사용자와 물리적으로 더 가까운 엣지 서버(edge server)에서 제공한다.
사용자와의 물리적 거리 단축은 왕복 시간(RTT)을 줄여주며, HTTP/2 또는 HTTP/3 같은 최적화 기술, 캐싱, 압축 등을 활용하여 오리진 서버에서 직접 가져오는 것보다 더 빠르게 콘텐츠를 제공할 수 있다. CDN을 활용하면 많은 경우 웹사이트의 TTFB(Time to First Byte, 최초 바이트 도달 시간)를 크게 향상시킬 수 있다.

---

## Test your knowledge

Q1. 전적으로 당신의 제어 범위 내에 있는 리디렉션 유형은 무엇인가요?
- same-origin redirect.
- cross-origin redirect.

Q2. Server-Timing 헤더는 여러 지표를 포함할 수 있나요?
- True

Q3. 최종 사용자와 물리적으로 가장 가까운 서버 유형은 무엇인가요?
- A Content Delivery Network's (CDN) edge servers.
- Your website's origin server.

---

## Up next: Understanding the critical path
다음 단계: 크리티컬 렌더링 경로 이해하기

이제 웹사이트 HTML에 관련된 몇 가지 성능 고려사항에 익숙해졌으므로, 가능한 한 빠르게 로딩될 수 있도록 보장할 수 있는 더 나은 위치에 있게 되었다.
하지만 이는 웹 성능 학습의 시작에 불과하다. 다음으로는 크리티컬 렌더링 경로(Critical Rendering Path)의 이론을 다룬다.
이 모듈에서는 렌더링 차단(render-blocking) 및 파싱 차단(parsing-blocking) 리소스와 같은 핵심 개념들과, 이들이 브라우저에서 페이지의 초기 렌더링을 가능한 한 빠르게 수행하는 데 어떤 역할을 하는지를 설명한다.
