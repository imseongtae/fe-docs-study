# Understand the critical path
크리티컬 렌더링 경로는 웹 페이지가 브라우저에 렌더링되기까지의 단계들을 의미한다. 페이지를 렌더링하려면, 브라우저는 HTML 문서 자체와 해당 문서를 렌더링하는 데 필요한 모든 크리티컬 리소스를 필요로 한다.

브라우저로 HTML 문서를 전달하는 과정은 이전의 일반적인 HTML 성능 고려사항(General HTML performance considerations) 모듈에서 다루었다. 하지만 이 모듈에서는 HTML 문서를 다운로드한 이후, 브라우저가 페이지를 렌더링하기 위해 수행하는 작업들에 대해 더 자세히 살펴볼 것이다.

## Table of contents
1. [Progressive rendering](#progressive-rendering)
1. [The (critical) rendering path](#the-critical-contentful-rendering-path)
1. [The critical contentful rendering path](#the-critical-contentful-rendering-path)
1. [Test your knowledge](#test-your-knowledge)
1. [Up next: Optimize resource loading](#up-next-optimize-resource-loading)

---

## Progressive rendering
점진적 렌더링

웹은 본질적으로 분산된 구조를 가지고 있다. 설치 후 사용하는 네이티브 애플리케이션과는 달리, 브라우저는 페이지를 렌더링하는 데 필요한 모든 리소스가 이미 존재할 것이라고 가정할 수 없다. 따라서 브라우저는 페이지를 점진적으로 렌더링하는 데 매우 능숙하다. 네이티브 앱은 일반적으로 설치 단계와 실행 단계가 명확히 나뉘어 있지만, 웹 페이지와 웹 앱은 이 두 단계 사이의 경계가 훨씬 덜 명확하며, 브라우저는 이러한 점을 염두에 두고 특별히 설계되어 있다.

브라우저가 렌더링할 리소스를 확보하면, 일반적으로 렌더링을 바로 시작한다. 따라서 문제는 언제 렌더링을 시작할지, 즉 “너무 이른 시점은 언제인가?“로 귀결된다.

브라우저가 HTML만 약간 확보한 시점에서 렌더링을 시작한다면—CSS나 필요한 자바스크립트 없이—페이지는 잠시 동안 깨진 것처럼 보일 수 있으며, 최종 렌더링에서는 크게 변경될 것이다. 이는 초기에는 빈 화면을 보여주다가 이후 더 나은 렌더링을 제공하는 방식보다 더 나쁜 사용자 경험을 초래한다.

반면, 브라우저가 모든 리소스를 확보할 때까지 기다린 후에야 렌더링을 시작한다면, 사용자는 실제로 더 일찍 사용할 수 있었던 페이지를 기다리는 상황에 놓이게 된다.

브라우저는 ‘명백히 깨진 화면’을 피하기 위해 기다려야 할 최소한의 리소스를 알아야 한다. 반면, 사용자에게 콘텐츠를 보여주기까지 더 이상 필요 이상으로 기다려서는 안 된다. 브라우저가 초기 렌더링을 수행하기 전까지의 일련의 단계들을 크리티컬 렌더링 경로(critical rendering path) 라고 한다.

크리티컬 렌더링 경로를 이해하면 초기 페이지 렌더링을 불필요하게 차단하지 않도록 하여 웹 성능을 향상시킬 수 있다. 동시에, 초기 렌더에 필요한 리소스를 렌더링 경로에서 제거함으로써 너무 이르게 렌더링되는 것을 방지해야 한다.

---

## The (critical) rendering path
크리티컬 렌더링 경로

렌더링 경로에는 다음과 같은 단계들이 포함된다:
- HTML로부터 DOM(Document Object Model)을 구성
- CSS로부터 CSSOM(CSS Object Model)을 구성
- DOM 또는 CSSOM을 변경하는 자바스크립트를 적용
- DOM과 CSSOM으로부터 렌더 트리(Render Tree)를 구성
- 페이지의 스타일 및 레이아웃을 수행하여 어떤 요소가 어디에 배치될지 결정
- 메모리에 요소의 픽셀을 그림(Paint)
- 픽셀이 겹치는 경우 컴포지팅(Composite) 수행
- 최종적으로 모든 픽셀을 실제 화면에 그림

이 모든 단계를 완료한 후에야, 사용자는 화면에서 콘텐츠를 볼 수 있다.

이 렌더링 프로세스는 여러 번 반복된다. 초기 렌더링이 이 프로세스를 최초로 호출하지만, 페이지 렌더링에 영향을 주는 더 많은 리소스가 확보되면 브라우저는 이 프로세스를 다시 실행하거나 일부만 실행하여 사용자에게 보이는 내용을 업데이트한다. 크리티컬 렌더링 경로는 이러한 초기 렌더링 프로세스에 초점을 맞추며, 이에 필요한 크리티컬 리소스에 따라 달라진다.

### What resources are on the critical rendering path?
크리티컬 렌더링 경로에 포함되는 리소스는 무엇인가?

브라우저는 초기 렌더링을 완료하기 전에 몇 가지 크리티컬 리소스가 다운로드되기를 기다려야 한다. 이 리소스들은 다음을 포함한다:
- HTML의 일부
- `<head>` 요소 안에 있는 렌더링 차단 CSS
- `<head>` 요소 안에 있는 렌더링 차단 JavaScript

핵심 포인트는, 브라우저는 HTML을 스트리밍 방식으로 처리한다는 점이다. 브라우저는 페이지 HTML의 일부라도 받자마자 즉시 처리하기 시작한다. 그러므로 전체 HTML을 다 받기 전에도 렌더링을 수행할 수 있다고 판단하여 실제로 렌더링을 수행하기도 한다.

중요한 점은 초기 렌더링에서는 일반적으로 다음 리소스들을 기다리지 않는다는 것이다:
- 전체 HTML
- 폰트
- 이미지
- <head> 요소 외부에 위치한, 렌더링 차단이 아닌 JavaScript (예: HTML 마지막에 위치한 <script>)
- <head> 요소 외부에 위치하거나, 현재 뷰포트에 적용되지 않는 media 속성이 지정된 CSS

폰트와 이미지는 브라우저 입장에서 콘텐츠를 채워 넣는 역할로 간주되며, 이후 페이지 재렌더링 시점에 삽입되면 된다고 여겨진다. 이로 인해 초기 렌더링에서는 비어 있는 공간이 생기거나, 폰트가 로드되기 전까지 텍스트가 보이지 않는 경우가 발생할 수 있다. 더 나쁜 경우는, 이미지 크기를 HTML에 명시하지 않은 상태에서 공간이 확보되지 않아 콘텐츠가 로드되면서 페이지 레이아웃이 변경되는 경우다. 이런 사용자 경험의 문제는 누적 레이아웃 이동(Cumulative Layout Shift, CLS) 지표로 측정된다.

<head> 요소는 크리티컬 렌더링 경로를 처리하는 데 핵심적인 역할을 한다. 다음 섹션에서는 이를 더 자세히 다룬다. <head> 요소의 내용을 최적화하는 것은 웹 성능 향상에서 핵심적인 부분이다. 지금은 단지 <head> 요소는 페이지의 메타데이터와 리소스를 포함하지만, 사용자가 볼 수 있는 실제 콘텐츠는 없다는 점만 알아두면 된다. 사용자에게 보여지는 콘텐츠는 <head> 다음에 오는 <body> 요소에 포함되어 있다. 브라우저가 콘텐츠를 렌더링하려면, 렌더링할 콘텐츠와 렌더링 방식을 설명하는 메타데이터 둘 다 필요하다.

하지만 <head> 요소에 명시된 모든 리소스가 초기 페이지 렌더링에 반드시 필요한 것은 아니다. 그래서 브라우저는 필요한 리소스만 기다린다. 어떤 리소스가 크리티컬 렌더링 경로에 포함되는지를 식별하려면, 렌더링 차단(render-blocking) 및 파서 차단(parser-blocking) CSS와 JavaScript에 대한 이해가 필요하다.

---

### Render-blocking resources
렌더링 차단 리소스

일부 리소스는 매우 중요하다고 간주되어 브라우저가 이를 처리할 때까지 렌더링을 일시 중단한다. CSS는 기본적으로 이 범주에 속한다.

브라우저가 CSS를 만나면—그것이 <style> 요소 내 인라인 CSS든, <link rel=stylesheet href="..."> 요소를 통한 외부 CSS든—CSS를 다운로드하고 처리할 때까지 다른 콘텐츠의 렌더링을 진행하지 않는다.

렌더링을 차단하는 리소스가 있다고 해서 브라우저가 아무 일도 하지 않는다는 의미는 아니다. 브라우저는 가능한 한 효율적으로 동작하도록 설계되어 있어, CSS 리소스를 다운로드하라고 판단되면 해당 요청을 보내고 렌더링은 잠시 멈추지만, HTML의 나머지를 계속 처리하며 할 수 있는 다른 작업들을 찾는다.

CSS와 같은 렌더링 차단 리소스는 과거에는 발견되는 즉시 전체 페이지 렌더링을 막았다. 즉, 어떤 CSS가 렌더링을 차단하느냐는 브라우저가 그것을 ‘발견했는가’에 따라 결정된다. 일부 브라우저(초기 Firefox와 현재 Chrome 포함)는 렌더링 차단 리소스 아래의 콘텐츠만 렌더링을 막는다. 따라서 크리티컬 렌더링 경로에서는 일반적으로 <head> 안에 있는 렌더링 차단 리소스를 주로 고려한다. 이들은 전체 페이지 렌더링을 실질적으로 막기 때문이다.

최근의 혁신 중 하나는 Chrome 105에 도입된 blocking=render 속성이다. 이 속성을 사용하면 <link>, <script>, <style> 요소를 명시적으로 “렌더링 차단”으로 지정할 수 있다. 이 방식은 해당 요소가 처리될 때까지는 렌더링을 차단하지만, 파서는 문서를 계속 처리할 수 있도록 한다.

---

### Parser-blocking resources
파서 차단 리소스

파서 차단 리소스는 브라우저가 HTML을 계속 파싱하면서 다른 작업을 수행하는 것을 방해하는 리소스를 의미한다. JavaScript는 기본적으로 파서 차단 요소다 (단, async, defer, 또는 module 속성이 명시되지 않은 경우에 한함). 이는 JavaScript가 DOM 또는 CSSOM을 실행 중에 변경할 수 있기 때문에, 브라우저가 해당 스크립트가 페이지에 어떤 영향을 미칠지를 알기 전에는 HTML 파싱을 계속할 수 없기 때문이다. 따라서 동기적 JavaScript는 파서를 차단한다.

파서를 차단하는 리소스는 사실상 렌더링도 차단한다. 파서가 해당 리소스를 완전히 처리할 때까지 다음 콘텐츠를 파싱하지 못하기 때문에, 그 이후에 있는 콘텐츠도 렌더링되지 못한다. 브라우저는 그 시점까지 받은 HTML을 렌더링할 수는 있지만, 크리티컬 렌더링 경로 관점에서는 <head>에 있는 모든 파서 차단 리소스가 페이지 전체 콘텐츠 렌더링을 막는다고 볼 수 있다.

파서를 차단하는 것은 단순히 렌더링을 막는 것보다 훨씬 더 큰 성능 비용을 초래할 수 있다. 이러한 이유로, 브라우저는 보조 HTML 파서인 프리로드 스캐너(preload scanner) 를 활용하여 파서가 차단되어 있는 동안에도 이후에 필요한 리소스를 미리 다운로드하려고 한다. 이는 실제 HTML을 파싱하는 것만큼은 아니지만, 네트워크 기능을 미리 작동시켜 이후 더 이상의 차단 상황을 줄이려는 전략이다.

---

### Identify blocking resources
많은 성능 분석 도구들은 렌더링 차단 리소스와 파서 차단 리소스를 식별해준다.
WebPageTest는 리소스의 URL 왼쪽에 주황색 원 아이콘을 표시하여 렌더링 차단 리소스를 나타낸다:

렌더링이 시작되기 전에 다운로드 및 처리가 필요한 모든 렌더링 차단 리소스는 워터폴 그래프에서 진한 초록색 실선으로 표시된다.

Lighthouse 역시 렌더링 차단 리소스를 식별하지만, 보다 미묘한 방식으로 표시하며, 해당 리소스가 실제로 페이지 렌더링을 지연시키는 경우에만 강조 표시한다.
이 방식은 렌더링 차단을 최소화하려는 상황에서의 오탐(false positive) 을 피하는 데 도움이 된다.

앞서 언급한 WebPageTest 사례와 동일한 페이지 URL을 Lighthouse로 분석하면, 스타일시트 중 하나만 렌더링 차단 리소스로 식별됨을 확인할 수 있다.

### Optimize the critical rendering path
크리티컬 렌더링 경로를 최적화하는 작업은 다음 두 가지를 포함한다:

1. HTML을 수신하는 데 걸리는 시간(TTFB, Time to First Byte)을 줄이기 — 이 부분은 앞선 모듈에서 자세히 설명되었다.
2. 렌더링 차단 리소스의 영향을 줄이기 — 이 부분은 다음 모듈에서 자세히 다루어진다.

---

## The critical contentful rendering path
오랫동안 크리티컬 렌더링 경로는 초기 렌더링에 초점을 맞춰왔다.
하지만 최근에는 사용자 중심의 웹 성능 지표들이 등장하면서, 크리티컬 렌더링 경로의 종료 지점을 단순히 첫 페인트(first paint) 시점으로 삼는 것이 적절한가에 대한 논의가 이루어지고 있다. 대신, 그 이후의 더 많은 콘텐츠가 표시되는 시점을 종료 지점으로 보자는 관점도 등장했다.

이러한 관점에서 대안으로 제시된 것은, Largest Contentful Paint (LCP) — 또는 First Contentful Paint (FCP) — 시점까지의 경로에 집중하는 것이다. 이를 contentful rendering path 또는 key path라고 부르기도 한다.
이 경우, 기존의 정의처럼 렌더링을 막는 리소스만이 아니라, 콘텐츠 렌더링에 꼭 필요한 리소스들까지 포함하게 된다.

자신이 “크리티컬”이라고 정의하는 시점이 무엇이든, 초기 렌더링 또는 주요 콘텐츠 표시를 지연시키는 요소가 무엇인지를 이해하는 것이 중요하다.
첫 페인트(first paint) 는 사용자를 위해 무언가를 화면에 렌더링할 수 있는 최초의 기회를 측정한다.
이 시점에는 의미 있는 요소—예를 들면 배경색이 아닌 텍스트나 이미지—가 렌더링되는 것이 이상적이다.
물론 의미 없는 콘텐츠라도 사용자에게 무언가를 보여준다는 점에서 가치가 있으며, 이것이 전통적 정의의 크리티컬 렌더링 경로를 여전히 측정해야 하는 이유이기도 하다.
동시에, 사용자에게 주요 콘텐츠가 언제 표시되었는가를 측정하는 것 역시 가치 있는 일이다.


### Identify the contentful rendering path
콘텐츠 렌더링 경로 식별하기

여러 도구들이 LCP 요소 및 해당 요소가 렌더링되는 시점을 식별할 수 있다.
Lighthouse는 LCP 요소뿐만 아니라, LCP 단계를 나누어 표시하고 각 단계에 걸린 시간도 보여준다. 이를 통해 어느 지점을 최적화할지 파악할 수 있다:

보다 복잡한 사이트의 경우, Lighthouse는 별도의 감사 항목(audit) 에서 크리티컬 요청 체인(critical request chains) 을 강조 표시해준다:

이 Lighthouse 감사 항목은 높은 우선순위(priority) 로 로드된 모든 리소스를 관찰하며, 여기에 웹 폰트나 Chrome이 자동으로 우선순위를 높게 설정한 기타 콘텐츠도 포함된다.
심지어 이들 리소스가 실제로 렌더링을 차단하지 않는다고 하더라도 말이다.\

---

## Up next: Optimize resource loading
이 모듈에서는 브라우저가 웹 페이지를 렌더링하는 이론, 특히 초기 렌더링을 완료하기 위해 필요한 사항들을 다루었다. 다음 모듈에서는 이 렌더링 경로를 어떻게 최적화할 수 있는지를 다룰 예정이며, 그 첫 단계는 리소스 로딩 최적화 방법을 학습하는 것이다.
